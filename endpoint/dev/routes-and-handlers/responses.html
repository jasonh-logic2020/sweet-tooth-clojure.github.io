<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Responses :: Sweet Tooth, a Clojure Single-Page App Framework</title>
    <link rel="canonical" href="https://www.sweettooth.dev/endpoint/dev/routes-and-handlers/responses.html">
    <link rel="prev" href="handlers-in-depth.html">
    <link rel="next" href="request-handling-intro.html">
    <meta name="generator" content="Antora 2.3.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.sweettooth.dev">Sweet Tooth, a Clojure Single-Page App Framework</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="https://github.com/sweet-tooth-clojure/">GitHub Repos</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/endpoint">endpoint</a>
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/frontend">frontend</a>
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/todo-example">todo example</a>
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/describe">describe</a>
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/documentation">documentation</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="endpoint" data-version="dev">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
      <!-- <h3 class="title"><a href="../index.html">endpoint</a></h3> -->
      <h3 class="title"><a href="../../../overview/dev/index.html">Overview</a></h3>
        <h3 class="title"><a href="../../../quickstart/dev/index.html">Quickstart</a></h3>
        <h3 class="title"><a href="../../../todo-example/dev/index.html">To-Do Example Walkthrough</a></h3>
  <ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../../todo-example/dev/initial-rendering.html">Initial Rendering</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../../todo-example/dev/form-handling.html">Form Handling</a>
  </li>
</ul>
  </li>
</ul>
      <h3 class="title"><a href="../index.html">endpoint</a></h3>
  <ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">Routes and Handlers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="routes-in-depth.html">Routes in Depth</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="handlers-in-depth.html">Handlers in Depth</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="responses.html">Responses</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="request-handling-intro.html">Introduction to Request Handling</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../architecture/index.html">Server Architecture: Components and Beyond</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../architecture/integrant-tutorial.html">Integrant Tutorial</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../architecture/duct-tutorial.html">Duct Tutorial</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../systems/index.html">Systems</a>
  </li>
</ul>
  </li>
</ul>
      <h3 class="title"><a href="../../../framework-design/dev/index.html">Framework Design</a></h3>
    </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">endpoint</span>
    <span class="version">dev</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">endpoint</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Framework Design</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../framework-design/dev/index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Overview</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../overview/dev/index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Quickstart</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../quickstart/dev/index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">To-Do Example Walkthrough</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../todo-example/dev/index.html">dev</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../overview/dev/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">endpoint</a></li>
    <li><a href="index.html">Routes and Handlers</a></li>
    <li><a href="responses.html">Responses</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<article class="doc">
<h1 class="page">Responses</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Sweet Tooth introduces a simple, extensible protocol for endpoint responses. The
Sweet Tooth frontend expects response bodies to be a vector of <em>segments</em>, where
each segment is a two-element vector of <code>[segment-type payload]</code>, like this:</p>
</div>
<div class="listingblock">
<div class="title">response example</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">[[:entity {:todo-list {1 {:todo-list/title "blah"}}}]
 [:page {:paginator-name :todo-lists
         :page-num       1}]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The frontend loops over responses and uses a multimethod to perform the correct
action for each segment. The segment types recognized out of the box are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:entity</code> the most common segment type, the frontend processes this by doing
a deep merge of the payload under the re-frame app db&#8217;s <code>:entity</code> key</p>
</li>
<li>
<p><code>:exception</code> this prints the backend&#8217;s exception message and stack trace in
the dev console. In theory this is useful during development</p>
</li>
<li>
<p><code>:page</code> this organizes pagination data. TODO document pagination</p>
</li>
<li>
<p><code>:errors</code> is used by forms to display validation errors. (For some reason it
is the only segment type that is pluralized. Whoops.)</p>
</li>
<li>
<p><code>:default</code> this simply merges the payload into the re-frame app db</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Whether or not this design choice is a terrible idea remains to be seen. The
rationale behind it is two-fold:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Making the response a vector of segments makes it easy to compose responses.
You can compose heterogenous data from different parts of your system just by
appending segments to the response vector. (This is in contrast to other
solutions I&#8217;ve seen where you have to jump through a lot of hoops to build a
single response map. If you don&#8217;t know what I&#8217;m referring to just roll with it
ðŸ˜Ž)</p>
</li>
<li>
<p>The frontend response handler is a multimethod, making it easy for devs to
introduce their own segment type</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The rest of this guide explains the ways in which Sweet Tooth makes it
convenient to respond with entities.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_returning_entities"><a class="anchor" href="#_returning_entities"></a>Returning Entities</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Most of the time you&#8217;ll want your endpoints to return either a single entity or
a collection of entities. The Sweet Tooth frontend expects such response bodies
to take this form:</p>
</div>
<div class="listingblock">
<div class="title">entity response</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">[[:entity {:entity-type {entity-id-1 entity-map-1
                         entity-id-2 entity-map-2
                         entity-id-3 entity-map-3}}]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The content of an actual response body might look like this:</p>
</div>
<div class="listingblock">
<div class="title">entity response</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">[[:entity {:todo-list {1 {:id 1 :todo-list/title "title 1"}
                       2 {:id 2 :toto-list/title "title 2"}
                       3 {:id 3 :toto-list/title "title 3"}}}]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This response body includes an <code>:entity</code> segment. The payload for an <code>:entity</code>
segment is a map that&#8217;s keyed first by the entities' type (<code>:todo-list</code>) and then
by then by the entities' ids.</p>
</div>
<div class="paragraph">
<p>TODO explain the rationale for this lightly indexed structure</p>
</div>
<div class="paragraph">
<p>It&#8217;d be pretty inconvenient to always have to format your data to fit this
structure. Thankfully, Sweet Tooth doesn&#8217;t make you do this. Most of the time,
you can just return maps or vectors of maps. Here are liberator status handlers
that show that:</p>
</div>
<div class="listingblock">
<div class="title">you can usually return maps or vectors of maps</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(def decisions
  {:collection
   {:get {:handle-ok (fn [ctx]
                       [{:id 1 :todo-list/title "title 1"}
                        {:id 2 :todo-list/title "title 2"}
                        {:id 1 :todo-list/title "title 3"}])}}

   :member
   {:get {:handle-ok (fn [ctx] {:id 1 :todo-list/title "title 1"})}}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above snippet shows how you would create handlers that respond to GET
requests at paths like <code>/todo-list</code> and <code>/todo-list/1</code>. <code>:handle-ok</code> is a status
handler function whose return value will be the body of the response. In the
case of <code>:collection</code> (which would correspond to <code>/todo-list</code>), the return value
is a vector of maps. For <code>:member</code> (which would correspond to <code>/todo-list/1</code>),
the return value is a single map.</p>
</div>
<div class="paragraph">
<p>You can return these values instead of the fully protocol-conformat values
because Sweet Tooth will format the responses from your handlers. It derives the
entity type from the endpoint namespace; the entity type for
<code>sweet-tooth.todo-example.backend.endpoint.todo-list</code> is <code>:todo-list</code>. It
formats responses using <code>sweet-tooth.endpoint.format/format-response</code>. If a
response consists of segments, like <code>[ [:errors &#8230;&#8203;] ]</code>, the function will
leave those segments untouched. Otherwise it will try to convert the data into
an entity segment.</p>
</div>
<div class="paragraph">
<p>But what if you want to return a mix of entities of different types? Or what if
the namespace name doesn&#8217;t match the name of the entity type?</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_returning_entities_of_different_types"><a class="anchor" href="#_returning_entities_of_different_types"></a>Returning entities of different types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can specify entity types in-line as metadata. All of these will work as
responses:</p>
</div>
<div class="listingblock">
<div class="title">you can specify entity type inline</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">^{:ent-type :todo-list} {:id 1 :todo-list/title "title 1"}

^{:ent-type :todo-list} [{:id 1 :todo-list/title "title 1"}
                         {:id 2 :todo-list/title "title 2"}
                         {:id 1 :todo-list/title "title 3"}]

[^{:ent-type :todo-list} {:id 1 :todo-list/title "title 1"}
 ^{:ent-type :todo}      {:id 1 :todo/title "todo 1"}]

[^{:ent-type :todo-list} [{:id 1 :todo-list/title "title 1"}
                          {:id 2 :todo-list/title "title 2"}]
 ^{:ent-type :todo}      [{:id 1 :todo/title "todo 1"}
                          {:id 2 :todo/title "todo 2"}]]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_setting_a_namespaces_entity_type"><a class="anchor" href="#_setting_a_namespaces_entity_type"></a>Setting a namespace&#8217;s entity type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If the name of your namespace doesn&#8217;t match the name of the entity type, you can
specify the ent-type in that namespace&#8217;s route:</p>
</div>
<div class="listingblock">
<div class="title">you can specify the entity type for a namespace</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(serr/expand-routes
 [[:sweet-tooth.backend.endpoint.restricted-todo-list {:ent-type :todo-list}]])</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_returning_errors"><a class="anchor" href="#_returning_errors"></a>Returning Errors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sweet Tooth&#8217;s frontend tools also recognize the <code>:errors</code> segment type:</p>
</div>
<div class="listingblock">
<div class="title">errors segment type</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">[[:errors {:todo-list/title ["required"]}]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If use a form&#8217;s <code>field</code> component it will automatically display
any errors.</p>
</div>
<div class="paragraph">
<p>TODO write more docs for field components and errors</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="handlers-in-depth.html">Handlers in Depth</a></span>
  <span class="next"><a href="request-handling-intro.html">Introduction to Request Handling</a></span>
</nav>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
    <a href="https://github.com/sweet-tooth-clojure/">Sweet Tooth</a>, a single-page app framework for Clojure
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
