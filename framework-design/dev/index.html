<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Framework Design :: Sweet Tooth, a Clojure Single-Page App Framework</title>
    <link rel="canonical" href="https://www.sweettooth.dev/framework-design/dev/index.html">
    <meta name="generator" content="Antora 2.3.3">
    <link rel="stylesheet" href="../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.sweettooth.dev">Sweet Tooth, a Clojure Single-Page App Framework</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="https://github.com/sweet-tooth-clojure/">GitHub Repos</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/endpoint">endpoint</a>
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/frontend">frontend</a>
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/todo-example">todo example</a>
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/describe">describe</a>
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/documentation">documentation</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="framework-design" data-version="dev">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
      <!-- <h3 class="title"><a href="index.html">Framework Design</a></h3> -->
      <h3 class="title"><a href="../../overview/dev/index.html">Overview</a></h3>
        <h3 class="title"><a href="../../quickstart/dev/index.html">Quickstart</a></h3>
        <h3 class="title"><a href="../../todo-example/dev/index.html">To-Do Example Walkthrough</a></h3>
  <ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../todo-example/dev/initial-rendering.html">Initial Rendering</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../todo-example/dev/form-handling.html">Form Handling</a>
  </li>
</ul>
  </li>
</ul>
      <h3 class="title"><a href="../../endpoint/dev/index.html">endpoint</a></h3>
  <ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../endpoint/dev/routes-and-handlers/index.html">Routes and Handlers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../endpoint/dev/routes-and-handlers/routes-in-depth.html">Routes in Depth</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../endpoint/dev/routes-and-handlers/handlers-in-depth.html">Handlers in Depth</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../endpoint/dev/routes-and-handlers/responses.html">Responses</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../endpoint/dev/routes-and-handlers/request-handling-intro.html">Introduction to Request Handling</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../endpoint/dev/architecture/index.html">Server Architecture: Components and Beyond</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../endpoint/dev/architecture/integrant-tutorial.html">Integrant Tutorial</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../endpoint/dev/architecture/duct-tutorial.html">Duct Tutorial</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../endpoint/dev/systems/index.html">Systems</a>
  </li>
</ul>
  </li>
</ul>
      <h3 class="title"><a href="index.html">Framework Design</a></h3>
    </nav>
</div>
<div class="nav-panel-explore " data-panel="explore">
  <div class="context">
    <span class="title">Framework Design</span>
    <span class="version">dev</span>
  </div>
  <ul class="components">
    <li class="component">
      <span class="title">endpoint</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../endpoint/dev/index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <span class="title">Framework Design</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Overview</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../overview/dev/index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Quickstart</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../quickstart/dev/index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">To-Do Example Walkthrough</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../todo-example/dev/index.html">dev</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../overview/dev/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
</nav>
</div>
  <div class="content">
<article class="doc">
<h1 class="page">Framework Design</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Writing a framework is a foolish endeavor that can be made a little less foolish
by clarifying what makes a good framework. If you&#8217;re going to spend an
inordinate amount of time toiling away in front of a monitor for no tangible
benefit then you might as well try to do a good job of it.</p>
</div>
<div class="paragraph">
<p>So far I haven&#8217;t found a guide to good framework design (or even a good
explanation of what a framework <em>is</em>!), so here&#8217;s my attempt to fill that void.
A framework framework, if you will. I hope you find it useful. I hope even more
that you&#8217;ve found something more useful and can point me to it. (If that sounds
like a cry for help, that&#8217;s because it is!)</p>
</div>
<div class="paragraph">
<p>(This guide is adapted from <a href="http://flyingmachinestudios.com/programming/why-programmers-need-frameworks/">Frameworks and Why (Clojure) Programmers Need Them</a>.)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_a_framework"><a class="anchor" href="#_what_is_a_framework"></a>What is a Framework?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A framework is a set of libraries that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Manages the complexity of coordinating the <em>resources</em> needed to write an
application&#8230;&#8203;</p>
</li>
<li>
<p>by providing <em>abstractions</em> for those resources&#8230;&#8203;</p>
</li>
<li>
<p>and <em>systems for communicating</em> between those resources&#8230;&#8203;</p>
</li>
<li>
<p>within an <em>environment</em>&#8230;&#8203;</p>
</li>
<li>
<p>so that programmers can <em>focus on writing the business logic</em> that&#8217;s specific
to their product</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I&#8217;ll elaborate on each of these points using examples from <a href="https://rubyonrails.org/">Rails</a> and from the
ultimate framework: the <em>operating system</em>.</p>
</div>
<div class="paragraph">
<p>You might wonder, how is an OS a framework? When you look at the list of
framework responsibilities, you&#8217;ll notice that the OS handles all of them, and
it handles them exceedingly well. Briefly: an OS provides virtual abstractions
for hardware resources so that programmers don&#8217;t have to focus on the details
of, say, pushing bytes onto some particular disk or managing CPU scheduling. It
also provides the conventions of a hierarchical filesystem with an addressing
system consisting of names separated by forward slashes, and these conventions
provide one way for resources to communicate with each other (Process A can
write to <code>/foo/bar</code> while Process B reads from it) - if every programmer came up
with her own bespoke addressing system, it would be a disaster. The OS handles
this for us so we can focus on application-specific tasks.</p>
</div>
<div class="paragraph">
<p>Because operating systems are such successful frameworks we&#8217;ll look at a few of
their features in some detail so that we can get a better understanding of what
good framework design looks like.</p>
</div>
<div class="sect2">
<h3 id="_coordinating_resources"><a class="anchor" href="#_coordinating_resources"></a>Coordinating Resources</h3>
<div class="paragraph">
<p><em>Resources</em> are the "materials" used by programs to do their work, and can be
divided into four categories: storage, computation, communication, and
interfaces. Examples of storage include files, databases, and caches.
Computation examples include processes, threads, actors, background jobs, and
core.async processes. For communication there are HTTP requests, message queues,
and event buses. Interfaces typically include keyboard and mouse, plus screens
and the systems used to display stuff on them: gui toolkits, browsers and the
DOM, etc.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/resource-categories.jpg" alt="resource categories">
</div>
<div class="title">Figure 1. the four resource categories</div>
</div>
<div class="paragraph">
<p>Specialized resources are built on top of more general-purpose resources. (Some
refer to these specialized resources as <em>services</em> or <em>components</em>.) We start
with hardware and build virtual resources on top. With storage, the OS starts
with disks and memory and creates the filesystem as a virtual storage resource
on top. Databases like Postgres use the filesystem to create another virtual
storage resource to handle use cases not met by the filesystem. Datomic uses
other databases like Cassandra or DynamoDB as its storage layer. Browsers create
their own virtual environments and introduce new resources like local storage
and cookies.</p>
</div>
<div class="paragraph">
<p>For computation, the OS introduces processes and threads as virtual resources
representing and organizing program execution. Erlang creates an environment
with a process model that&#8217;s dramatically different from the underlying OS&#8217;s.
Same deal with Clojure&#8217;s <code>core.async</code>, which introduces the <em>communicating
sequential processes</em> computation model. It&#8217;s a virtual model defined by Clojure
macros, "compiled" to core clojure, then compiled to JVM bytecode (or
JavaScript!), which then has to be executed by operating system processes.</p>
</div>
<div class="paragraph">
<p>Interfaces follow the same pattern: on the visual display side, the OS paints to
monitors, applications paint to their own virtual canvas, browsers are
applications which introduce their own resources (the DOM and <code>&lt;canvas&gt;</code>), and
React introduces a virtual DOM. Emacs is an operating system on top of the
operating system, and it provides windows and frames.</p>
</div>
<div class="paragraph">
<p>Resources <em>manage</em> their own <em>entities</em>: in a database, entities could include
tables, rows, triggers, and sequences. Filesystem entities include directories
and files. A GUI manages windows, menu bars, and other components. To manage a
resource is to create, validate, secure, and dispose of resource entities.</p>
</div>
<div class="paragraph">
<p>(I realize that this description of <em>resource</em> is not the kind of airtight,
axiomatic, comprehensive description that programmers like. One shortcoming is
that the boundary between resource and application is pretty thin: Postgres is
an application in its own right, but from the perspective of a Rails app it&#8217;s a
resource. Still, hopefully my use of <em>resource</em> is clear enough that you
nevertheless understand what the f I&#8217;m talking about when I talk about
resources.)</p>
</div>
<div class="paragraph">
<p><em>Coordinating</em> these resources is inherently complex. Hell, coordinating anything
is complex. I still remember the first time I got smacked in the face with a
baseball in little league thanks to a lack of coordination. There was also a
time period where I, as a child, took tae kwon do classes and frequently ended
up sitting with my back against the wall with my eyes closed in pain because a)
my mom for some reason refused to buy me an athletic cup and b) I did not
possess the coordination to otherwise protect myself during sparring.</p>
</div>
<div class="paragraph">
<p>When building a product, you have to decide how to create, validate, secure, and
dispose of resource entities; how to convey entities from one resource to
another; and how to deal with issues like timing (race conditions) and failure
handling that arise whenever resources interact, all without getting hit in the
face. Rails, for instance, was designed to coordinate browsers, HTTP servers,
and databases. It had to convey user input to a database, and also retrieve and
render database records for display by the user interface, via HTTP requests and
responses.</p>
</div>
<div class="paragraph">
<p>There is no obvious or objectively correct way to coordinate these resources. In
Rails, HTTP requests would get dispatched to a Controller, which was responsible
for interacting with a database and making data available to a View, which would
render HTML that could be sent back to the browser.</p>
</div>
<div class="paragraph">
<p>You don&#8217;t <em>have</em> to coordinate web app resources using the Model/View/Controller
(MVC) approach Rails uses, but you do have to coordinate these resources
<em>somehow</em>. These decisions involve making tradeoffs and imposing constraints to
achieve a balance of extensibility (creating a system generic enough for new
resources to participate) and power (allowing the system to fully exploit the
unique features of a specific resource).</p>
</div>
<div class="paragraph">
<p>This is a very difficult task even for experienced developers, and the choices
you make could have negative repercussions that aren&#8217;t apparent until you&#8217;re
heavily invested in them. With Rails, for instance, ActiveRecord (AR) provided a
good generic abstraction for databases, but early on it was very easy to produce
extremely inefficient SQL, and sometimes very difficult to produce efficient
SQL. You&#8217;d often have to hand-write SQL, eliminating some of the benefits of
using AR in the first place.</p>
</div>
<div class="paragraph">
<p>For complete beginners, the task of making these tradeoffs is impossible because
doing so requires experience. Beginners won&#8217;t even know that it&#8217;s necessary to
make these decisions. At the same time, more experienced developers would prefer
to spend their time and energy solving more important problems.</p>
</div>
<div class="paragraph">
<p>Frameworks make these decisions for us, allowing us to focus on business logic.
The <em>manage</em> resources by by introducing <em>communication systems</em> and
<em>abstractions</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resource_management"><a class="anchor" href="#_resource_management"></a>Resource Management</h3>
<div class="paragraph">
<p>Let&#8217;s decompose "resource management" to better understand what exactly
frameworks are responsible for. To start, it&#8217;s useful to break down resource
management into the <em>component level</em> and the <em>entity level</em>. At the component
level, we talk about:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Starting and stopping a database</p>
</li>
<li>
<p>Starting, stopping, pausing, and resuming a job scheduler</p>
</li>
<li>
<p>Starting and stopping an HTTP server</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In general, component management is about start, stopping, and sometimes pausing
and resuming a sub-system which itself manages entities. For operating systems,
we have tools like systemd and upstart to handle this. In Clojure apps, we have
<a href="https://github.com/weavejester/integrant">Integrant</a>, <a href="https://github.com/tolitius/mount">mount</a>, and <a href="https://github.com/stuartsierra/component">component</a>.</p>
</div>
<div class="paragraph">
<p>At the entity level, resource management involves task like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>create / read / update / delete a database record</p>
</li>
<li>
<p>add / pause / remove a background job</p>
</li>
<li>
<p>create / wait for / respond to XHR request</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Stepping back, we might say that resource management is about changing state and
responding to state changes. (You can even think of components themselves as
entities of the larger system; is starting and stopping a database fundamentally
different from managing background jobs?)</p>
</div>
<div class="paragraph">
<p>"State" is one of those very overloaded programming terms, so like, don&#8217;t kill
me if I use it differently than you. But when talking about state, I think it&#8217;s
important to differentiate between <em>operational state</em> and <em>content</em>.</p>
</div>
<div class="paragraph">
<p>Content examples include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The screenplay you&#8217;re writing</p>
</li>
<li>
<p>The source of the framework you&#8217;re building for some reason</p>
</li>
<li>
<p>HTTP headers and body</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We perform CRUD operations to change content.</p>
</div>
<div class="paragraph">
<p>Operational state, on the other hand, is metadata relevant to state change
operations. (Note to self: this definition may need work?) Examples include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Whether form input is valid or invalid</p>
</li>
<li>
<p>Whether a file is writeable or read-only</p>
</li>
<li>
<p>Whether an operation succeeded or failed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This distinction has been helpful for me because it&#8217;s helped me be more rigorous
in creating good user experiences. A lot of creating a good user experience is
about providing feedback to the user. But what is feedback? Feedback is
information about the operational state of resource entities, and frameworks
help us manage that.</p>
</div>
<div class="paragraph">
<p>So anyway, we have to manage resources somehow. But how? That&#8217;s where
abstractions come in.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resource_abstractions"><a class="anchor" href="#_resource_abstractions"></a>Resource Abstractions</h3>
<div class="paragraph">
<p>Our software interacts with resources via their <em>abstractions</em>. I think of
abstractions as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the data structures used to represent a resource</p>
</li>
<li>
<p>the set of messages for changing retrieving state</p>
</li>
<li>
<p>the set of possible operational states</p>
</li>
<li>
<p>the mechanisms for responding to operational state changes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>(<em>Abstraction</em> might be a terrible word to use here. Every developer over three
years old has their own definition, and if mine doesn&#8217;t correspond to yours just
cut me a little slack and run with it :)</p>
</div>
<div class="paragraph">
<p>Rails exposes a database resource that your application code interacts with via
the <code>ActiveRecord</code> abstraction. Tables correspond to classes, and rows to
objects of that class. This a choice with tradeoffs - rows could have been
represented as Ruby hashes (a primitive akin to a JSON object), which might have
made them more portable while making it more difficult to concisely express
database operations like <code>save</code> and <code>destroy</code>. The abstraction also responds to
<code>find</code>, <code>create</code>, <code>update</code>, and <code>destroy</code>. You respond to operational state
changes via lifecycle callback methods like <code>before/validation</code>. Frameworks add
value by identifying these state transitions and providing interfaces for them
when they&#8217;re absent from the underlying resource.</p>
</div>
<div class="paragraph">
<p>You already know this, but it bears saying: abstractions let us code at a higher
level. Framework abstractions handle the concerns that are specific to resource
management, letting us focus on building products. Designed well, they enable
loose coupling.</p>
</div>
<div class="paragraph">
<p>Nothing exemplifies this better than the massively successful <em>file</em> abstraction
that the UNIX framework introduced. We&#8217;re going to look at in detail because it
embodies design wisdom that can help us understand what makes a good framework.</p>
</div>
<div class="paragraph">
<p>The core file functions are <code>open</code>, <code>read</code>, <code>write</code>, and <code>close</code>. Files are
represented as sequential streams of bytes, which is just as much a choice as
ActiveRecord&#8217;s choice to use Ruby objects. Within processes, open files are
represented as <em>file descriptors</em>, which are usually a small integer. The <code>open</code>
function takes a path and returns a file descriptor, and <code>read</code>, <code>write</code>, and
<code>close</code> take a file descriptor as an argument to do their work.</p>
</div>
<div class="paragraph">
<p>Now here&#8217;s the amazing magical kicker: <em>file</em> doesn&#8217;t have to mean <em>file on
disk</em>. Just as Rails implements the ActiveRecord abstraction for MySQL and
Postgres, the OS implements the file abstraction for <strong>pipes</strong>, terminals, and
other resources, meaning that your programs can write to them using the same
system calls as you&#8217;d use to write files to disk - indeed, from your program&#8217;s
standpoint, all it knows is that it&#8217;s writing to a file; it doesn&#8217;t know that
the "file" that a file descriptor refers to might actually be a pipe.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Exercise for the reader: write a couple paragraphs explaining precisely
the design choices that enable this degree of loose coupling. How can these
choices help us in evaluating and designing frameworks?
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This design is a huge part of UNIX&#8217;s famed simplicity. It&#8217;s what lets us run
this in a shell:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># list files in the current directory and perform a word count on the output
ls | wc</code></pre>
</div>
</div>
<div class="paragraph">
<p>The shell interprets this by launching an <code>ls</code> process. Normally, when a process
is launched it creates three file descriptors (which, remember, represent open
files): <code>0</code> for <code>STDIN</code>, <code>1</code> for <code>STDOUT</code>, and <code>2</code> for <code>STDERR</code>, and the shell
sets each file descriptor to refer to your terminal (terminals can be files!!
what!?!?). Your shell sees the pipe, <code>|</code>, and sets <code>ls&#8217;s `STDOUT</code> to the pipe&#8217;s
<code>STDIN</code>, and the pipe&#8217;s <code>STDOUT</code> to <code>wc&#8217;s `STDIN</code>. The pipe links processes'
file descriptors, while the processes get to read and write "files" without
having to know what&#8217;s actually on the other end. No joke, every time I think of
this I get a little excited tingle at the base of my spine because I am a:</p>
</div>
<div class="paragraph">
<p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/IRsPheErBj8[https://www.youtube.com/embed/IRsPheErBj8]"
frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope;
picture-in-picture" allowfullscreen></iframe>
</p>
</div>
<div class="paragraph">
<p>This is why file I/O is referred to as <em>the universal I/O model</em>. I&#8217;ll have more
to say about this in the next section, but I share it here to illustrate how
much more powerful your programming environment can be if you find the right
abstractions. The file I/O model still dominates decades after its introduction,
making our lives easier <em>without our even having to understand how it actually
works</em>.</p>
</div>
<div class="paragraph">
<p>The canonical first exercise any beginner programmer performs is to write a
program that prints out, <em>What up, y&#8217;all?</em>. This program makes use of the file
model, but the beginner doesn&#8217;t have to even know that such a thing exists. This
is what a good framework does. A well-designed framework lets you easily get
started building simple applications, without preventing you building more
complicated and useful ones as you learn more.</p>
</div>
<div class="paragraph">
<p>One final point about abstractions: they define mechanisms for calling your
application&#8217;s code. We saw this a bit earlier with ActiveRecord&#8217;s lifecycle
methods. Frameworks will usually provide the overall structure for how an
application should interact with its environment, defining sets of events that
you write custom handlers for. With ActiveRecord lifecycles, the structure of
<code>before/create</code>, <code>create</code>, <code>after/create</code> is predetermined, but you can define
what happens at each step. This pattern is called <em>inversion of control</em>, and
many developers consider it a key feature of frameworks.</p>
</div>
<div class="paragraph">
<p>With *nix operating systems, you could say that in C programs the <code>main</code>
function is a kind of <code>onStart</code> callback. The OS calls <code>main</code>, and <code>main</code> tells
the OS what instructions should be run. However, the OS controls when
instructions are actually executed because the OS is in charge of scheduling.
It&#8217;s a kind of inversion of control, right? 🤔</p>
</div>
</div>
<div class="sect2">
<h3 id="_communication"><a class="anchor" href="#_communication"></a>Communication</h3>
<div class="paragraph">
<p>Frameworks coordinate resources, and (it&#8217;s almost a tautology to say this)
coordination requires <em>communication</em>. Communication is <em>hard</em>. Frameworks make
it easier by translating the disparate "languages" spoken by resources into one
or more common languages that are easy to understand and efficient, while also
ensuring extensibility and composability. Frameworks also do some of the work of
ensuring resilience. This usually entails:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Establishing naming and addressing conventions</p>
</li>
<li>
<p>Establishing conventions for how to structure content</p>
</li>
<li>
<p>Introducing communication brokers</p>
</li>
<li>
<p>Handling communication failures (the database is down! that file
doesn&#8217;t exist!)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>One example many people are familiar with is the HTTP stack, a "language" used
to communicate between browser and server resources:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTTP structures content (request headers and request body as text)</p>
</li>
<li>
<p>TCP handles communication failures</p>
</li>
<li>
<p>IP handles addressing</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_conventions"><a class="anchor" href="#_conventions"></a>Conventions</h4>
<div class="paragraph">
<p>The file model is a "common language", and the OS uses device drivers to
translate between between the file model and whatever local language is spoken
by hardware devices. It has naming and addressing conventions, letting you
specify files on the filesystem using character strings separated by slashes
that it translates to an internal inode (a data structure that stores file and
directory details, like ownership and permissions). We&#8217;re so used to this that
it&#8217;s easy to forget it&#8217;s a convention; *nix systems could have been designed so
that you had to refer to files using a number or a UUID. The file descriptors I
described in the last section are also a convention.</p>
</div>
<div class="paragraph">
<p>Another convention the file model introduces is to structure content as byte
streams, as opposed to bit streams, character streams, or xml documents.
However, bytes are usually too low-level, so the OS includes a suite of command
line tools that introduce the further convention of structuring bytes by
interpreting them as characters (<code>sed</code>, <code>awk</code>, <code>grep</code>, and friends). More
recently, more tools have been introduced that interpret text as YAML or JSON.
The Clojure world has further tools to interpret JSON as transit. My YAML tools
can&#8217;t do jack with your JSON files, but because these formats are all expressed
in terms of lower-level formats, the lower-level tools can still work with them.
Structure affects composability.</p>
</div>
<div class="paragraph">
<p>The file model&#8217;s simplicity is what allows it to be the "universal I/O model." I
mean, just imagine if all Linux processes had to communicate with XML instead of
byte streams! Hoo boy, what a crazy world that would be. Having a simple,
universal communication system makes it extremely easy for new resources to
participate without having to be directly aware of each other. It allows us to
easily compose command line tools. It allows one program to write to a log while
another reads from it. In other words, it enables loose coupling and all the
attendant benefits.</p>
</div>
</div>
<div class="sect3">
<h4 id="_communication_brokers"><a class="anchor" href="#_communication_brokers"></a>Communication Brokers</h4>
<div class="paragraph">
<p><em>Globally addressable communication brokers</em> (like the filesystem, or Kafka
queues, or databases) are essential to enabling composable systems. <em>Global</em>
means that every resource can access it. <em>Addressable</em> means that the broker
maintains identifiers for entities independently of its clients, and it&#8217;s
possible for clients to specify entities using those identifiers. <em>Communication
broker</em> means that the system&#8217;s purpose is to convey data from one resource to
another, and it has well-defined semantics: a queue has FIFO semantics, the file
system has update-in-place semantics, etc.</p>
</div>
<div class="paragraph">
<p>If Linux had no filesystem and processes were only allowed to communicate via
pipes, it would be a nightmare. Indirect communication is more flexible than
direct communication. It supports decoupling over time, in that reads and writes
don&#8217;t have to happen synchronously. It also allows participants to drop in and
out of the communication system independently of each other. (By the way, I
can&#8217;t think of the name for this concept or some better way to express it, and
would love feedback here.)</p>
</div>
<div class="paragraph">
<p>I think this is the trickiest part of framework design. At the beginning of the
article I mentioned that developers might end up hacking around a framework&#8217;s
constraints, and I think the main constraint is often the absence of a
communication broker. The framework&#8217;s designers introduce new resources and
abstractions, but the only way to compose them is through direct communication,
and sometimes that direct communication is handled magically. (I seem to recall
that Rails worked with this way, with tight coupling between Controller and
Views and a lack of options for conveying Controller data to other parts of the
system). If someone wants to introduce new abstractions, they have to untangle
all the magic and hook deep into the framework&#8217;s internals, using&#8201;&#8212;&#8201;or even
patching!&#8201;&#8212;&#8201;code that&#8217;s meant to be private.</p>
</div>
<div class="paragraph">
<p>I remember running into this with Rails back when MongoDB was released; the
<em>document database</em> resource was sufficiently different from the <em>relational
database resource</em> that it was pretty much impossible for MongoDB to take part
in the ActiveRecord abstraction, and it was also very difficult to introduce a
new data store abstraction that would play well with the rest of the Rails
ecosystem.</p>
</div>
<div class="paragraph">
<p>For a more current example, a frontend framework might identify the form as a
resource, and create a nice abstraction for it that handles things like
validation and the submission lifecycle. If the form abstraction is written in a
framework that has no communication broker (like a global state container), then
it will be very difficult to meet the common use case of using a form to filter
rows in a table because there&#8217;s no way for the code that renders table data to
access the form inputs' values. You might come up with some hack like defining
handlers for exporting the form&#8217;s state, but doing this on an ad-hoc basis
results in confusing and brittle code.</p>
</div>
<div class="paragraph">
<p>By contrast, the presence of a communication broker can make life much easier.
In the Clojure world, the React frameworks <a href="https://github.com/Day8/re-frame/">re-frame</a> and <a href="https://github.com/omcljs/om">om.next</a> have embraced
global state atoms, a kind of communication broker similar to the filesystem
(atoms are an in-memory storage mechanism). They also both have well defined
communication protocols. I&#8217;m not very familiar with <a href="https://redux.js.org/">Redux</a> but I&#8217;ve heard tell
that it also has embraced a global, central state container.</p>
</div>
<div class="paragraph">
<p>If you create a form abstraction using re-frame, it&#8217;s possible to track its
state in a global state atom. It&#8217;s further possible to establish a naming
convention for forms, making it easier for other participants to look up the
form&#8217;s data and react to it. (Sweet Tooth does this.)</p>
</div>
<div class="paragraph">
<p>Communication systems are fundamental. Without them, it&#8217;s difficult to build
anything but the simplest applications. By providing communication systems,
frameworks relieve much of the cognitive burden of building a program. By
establishing communication standards, frameworks make it possible for developers
to create composable tools, tools that benefit everybody who uses that
framework. Standards make infrastructure possible, and infrastructure enables
productivity.</p>
</div>
<div class="paragraph">
<p>In this section I focused primarily on the file model because it&#8217;s been so
successful and I think we can learn a lot from it. Other models include event
buses and message queues. I&#8217;m not going to write about these because I&#8217;m not
made of words, ok?!?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_environments"><a class="anchor" href="#_environments"></a>Environments</h3>
<div class="paragraph">
<p>Frameworks are built to coordinate resources within a particular <em>environment</em>.
When we talk about desktop apps, web apps, single page apps, and mobile apps,
we&#8217;re talking about different environments. From the developer&#8217;s perspective,
environments are distinguished by the resources that are available, while from
the user&#8217;s perspective different environments entail different usage patterns
and expectations about distribution, availability, licensing, and payment.</p>
</div>
<div class="paragraph">
<p>As technology advances, new resources become available (the Internet! databases!
smart phones! powerful browsers! AWS!), new environments evolve to combine those
resources, and frameworks are created to target those environments. This is why
we talk about mobile frameworks and desktop frameworks and the like.</p>
</div>
<div class="paragraph">
<p>One of the reasons I stopped using Rails was because it was a <em>web application
framework</em>, but I wanted to build <em>single page applications</em>. At the time
(around 2012?), I was learning to use Angular and wanted to deploy applications
that used it, but it didn&#8217;t really fit with Rails&#8217;s design.</p>
</div>
<div class="paragraph">
<p>And that&#8217;s OK. Some people write programs for Linux, some people write for
macOS, some people still write for Windows for some reason (just kidding! don&#8217;t
kill me!). A framework is a tool, and tools are built for a specific purpose. If
you&#8217;re trying to achieve a purpose the tool isn&#8217;t built for, use a different
tool.</p>
</div>
</div>
<div class="sect2">
<h3 id="_additional_responsibilities"><a class="anchor" href="#_additional_responsibilities"></a>Additional Responsibilities</h3>
<div class="paragraph">
<p>While the core purpose of frameworks is to manage resources, they also handle
secondary responsibilities, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Code generation</p>
</li>
<li>
<p>Build tooling</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Code generation reduces the amount of effort it takes to introduce the artifacts
(files, text) required to add new instances of a framework abstraction (like a
Model in a Rails app). This effort takes two forms: the mechanical effort of
typing, and the mental effort of remembering what the code is supposed to look
like.</p>
</div>
<div class="paragraph">
<p>Build tooling is helpful in fulfilling an application framework&#8217;s purpose of
empowering you to create, well, applications. It reduces the effort required to
produce a working application.</p>
</div>
<div class="paragraph">
<p>Frameworks might take on additional responsibilities, but I think I&#8217;ve covered
the most important ones here. Now that we have a better idea of what a framework
<em>is</em>, we can start exploring what makes a framework <em>good</em>. We can see a hint in
the previous two paragraphs: frameworks reduce effort. They make our jobs
<em>easier</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_good_framework_design"><a class="anchor" href="#_what_is_good_framework_design"></a>What is good framework design?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If we take a step back and look at all the a framework is responsible for, we
can see that frameworks make development <em>easier</em>. <em>Easier</em> simply means that
less effort is involved: mental effort to understand your system (what we call
<em>struggling</em>), mechanical effort typing (what we call <em>tedium</em>), repeated effort
implementing solutions to the same problem over and over (what we call
<em>consulting</em>). A well-designed framework is one that makes development easier,
both in the short term and in the long term.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>I think the whole simple vs. easy discussion in the Clojure world has been
effective at conveying the value of simple constructs, but at the cost of making
it almost, like, gauche to advocate for the importance of making work easier for
developers. I think this has ultimately been detrimental to the Clojure
community.</p>
</div>
<div class="paragraph">
<p>This comes in part from defining easy as "near at hand", which is not how anyone
actually uses the word. Easy and difficult describe the amount of effort
involved. So it&#8217;s been weird to see "easy" disparaged, because that&#8217;s what the
programming game is all about! It&#8217;s about reducing effort.</p>
</div>
<div class="paragraph">
<p>The simple vs. easy discussion has it all backwards: Simplicity&#8217;s value is that
it makes development easier. Would anyone advocate for simple code if it made
programming harder? Also, it is just one factor of many to consider when writing
software. Imagine writing the simplest code in the universe, and then running it
through a minifier: it&#8217;s still simple, but now it&#8217;s significantly more difficult
to understand.</p>
</div>
<div class="paragraph">
<p>It seemed to me like the framing of SvE was meant mostly to caution against
optimizing for short-term effort at the expense of increasing long-term effort,
which I think is helpful. But it also seemed like it was meant to chastise
people for trying to reduce effort in any fashion, and I think that was
detrimental. Specifically, the idea of building web sites in a day was derided
as "a stupid thing to be important."</p>
</div>
<div class="paragraph">
<p>But it&#8217;s not stupid. It&#8217;s helpful to make things easy. It&#8217;s helpful to do the
work of identifying where the people who use tools might struggle, and to reduce
the amount of struggling necessary.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>How do we accomplish this? First, by writing code to meets the responsibilities
listed in the last section. But just writing some code isn&#8217;t enough: it needs to
be easy to use and understand.</p>
</div>
<div class="paragraph">
<p>Figuring out and articulating my thoughts on this
subject is definitely an ongoing process, but here&#8217;s what I have so far: A
well-designed framework is <em>modular</em>, <em>extensible</em>, and <em>composable</em>.</p>
</div>
<div class="sect2">
<h3 id="_modular"><a class="anchor" href="#_modular"></a>Modular</h3>
<div class="paragraph">
<p><em>Modular</em> means that the framework&#8217;s responsibilities should be well-defined,
and it should be possible for you to swap out one implementation of a
responsibility for another. For example, Sweet Tooth uses reitit for routing,
but it&#8217;s possible for you to use a different library as long as you can adapt it
to the routing protocol.</p>
</div>
<div class="paragraph">
<p>At the same time, some core responsibilities cannot be made modular. Sweet Tooth
is built on top of Integrant, which is used to define, configure, and manage the
lifecycle of the system&#8217;s architecture; you can&#8217;t use the mount or component
libraries instead On the frontend, ST is built on top of re-frame, which act as
a kind of filesystem and messaging system. Using Sweet Tooth means using
re-frame and Integrant.</p>
</div>
</div>
<div class="sect2">
<h3 id="_extensible"><a class="anchor" href="#_extensible"></a>Extensible</h3>
<div class="paragraph">
<p><em>Extensibile</em> means that devs should be able to easily introduce custom
implementations of core framework offerings. (OMG I need to find a better way to
phrase this!) In practice this mostly means identifying where it&#8217;s possible and
appropriate to use a multimethod, and doing so. One example is Sweet Tooth&#8217;s
form component system: ST takes care of all the details for storing a form
input&#8217;s data on the frontend and submiting that data to the backend. It&#8217;s
trivial to extend the system for new components, for example by introducing a
markdown editor component. The to-do example walkthrough will show you how this
works.</p>
</div>
</div>
<div class="sect2">
<h3 id="_composable"><a class="anchor" href="#_composable"></a>Composable</h3>
<div class="paragraph">
<p><em>Composable</em> means two things: first, that the framework should be written from
a UNIX-y "do one thing well" standpoint. Back to form components: the form
component system is layered, with re-frame subscriptions and handlers as the
bottom layer. A multimethod composes those subscriptions and handlers into DOM
options like <code>:on-change</code> and <code>:checked</code> as appropriate for the different kinds
of inputs. You can use this system for composing the re-frame subscriptions and
handlers, or you could introduce your own.</p>
</div>
<div class="paragraph">
<p>The second meaning is that it should be possible to write framework plugins. For
example, you should be able to write an auth plugin that spans the frontend and
backend, introducing API endpoints and reagent components that Just Work. I
haven&#8217;t put much thought into supporting this kind of compsability.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_clojure_framework"><a class="anchor" href="#_a_clojure_framework"></a>A Clojure Framework</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Frameworks are all about managing the complexity of coordinating resources.
Well, guess what: Managing Complexity is Clojure&#8217;s middle name. Clojure
"Managing Complexity" McCarthy-Lisp. Personally, I want a single-page app (SPA)
framework, and there are many aspects of Clojure&#8217;s design and philosophy that I
think will make it possible to create one that seriously kicks ass. I&#8217;ll give
just a few examples.</p>
</div>
<div class="paragraph">
<p>First, consider how Linux tools like <code>sed</code> and <code>awk</code> are text-oriented.
Developers can add additional structure to text by formatting it as JSON or
YAML, and those text-processing tools can still work the structured text.</p>
</div>
<div class="paragraph">
<p>In the same way, Clojure&#8217;s emphasis on simple data structures means that we can
create specialized structures to represent forms and ajax request, and tools to
process those structures. If we define those structures in terms of maps and
vectors, though, we&#8217;ll still be able to use a vast ecosystem of functions for
working with those simpler structures. In other words, creating specialized
structures does not preclude us from using the tools built for simpler
structures, and this isn&#8217;t the case for many other languages.</p>
</div>
<div class="paragraph">
<p>Second, Clojure&#8217;s abstraction mechanisms (protocols and multimethods) are
extremely flexible, making it easy for us to implement abstractions for new
resources as they become available.</p>
</div>
<div class="paragraph">
<p>Third, <em>you can use the same language for the frontend and backend!!!</em> Not only
that, Transit allows the two to effortlessly communicate. This eliminates an
entire class of coordination problems that frameworks in other languages have to
contend with.</p>
</div>
<div class="paragraph">
<p>In my opinion, the Clojurian stance that frameworks are more trouble than
they&#8217;re worth is completely backwards: Clojure gives us the foundation to build
a completely kick-ass framework! One that&#8217;s simple <em>and</em> easy. One can dream,
right?</p>
</div>
<div class="paragraph">
<p>My ambition in building a SPA framework is to empower current and future Clojure
devs to get our ideas into production <em>fast</em>. I want us to be able to spend more
time on the hard stuff, the fun stuff, the interesting stuff. And I want us to
be able to easily ship with confidence.</p>
</div>
<div class="paragraph">
<p>The framework I&#8217;m building is built on top of some truly amazing libraries,
primarily Integrant, re-frame, and Liberator. Integrant introduces a <em>component</em>
abstraction and handles the start/stop lifecycle of an application. re-frame
provides a filesystem and communication broker for the frontend. Liberator
introduces a standard model for handling HTTP requests.</p>
</div>
<div class="paragraph">
<p>If my framework is useful at all it&#8217;s because the creators of those tools have
done all the heavy lifting. My framework introduces more resources and
abstractions specific to creating single-page apps. For example, it creates an
abstraction for wrapping AJAX requests so that you can easily display activity
indicators when a request is active. It creates a form abstraction that handles
all the plumbing of handling input changes and dispatching form submission, as
well the entire form lifecycle of <em>fresh</em>, <em>dirty</em>, <em>submitted</em>, <em>invalid</em>,
<em>succeeded</em>, etc. It imposes some conventions for organizing data.</p>
</div>
<div class="paragraph">
<p>If you&#8217;d like to see a production app that uses the framework, however, I invite
you to check out [Grateful Place](<a href="https://gratefulplace.com">https://gratefulplace.com</a>), a community site
for people who want to support each other in growing resilience, peace, and joy
by practicing compassion, gratitude, generosity, and other positive values.</p>
</div>
<div class="paragraph">
<p>Other Clojure frameworks include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[Luminus](<a href="http://www.luminusweb.net">http://www.luminusweb.net</a>)</p>
</li>
<li>
<p>[Fulcro](<a href="http://book.fulcrologic.com/">http://book.fulcrologic.com/</a>) which probably does everything I want
my framework to, only better</p>
</li>
<li>
<p>[re-frame](<a href="https://github.com/Day8/re-frame/">https://github.com/Day8/re-frame/</a>) remains my favorite frontend
framework</p>
</li>
<li>
<p>[duct](<a href="https://github.com/duct-framework/duct">https://github.com/duct-framework/duct</a>) is great but its docs aren&#8217;t
that great yet</p>
</li>
<li>
<p>[Coast on Clojure](<a href="https://github.com/coast-framework/coast">https://github.com/coast-framework/coast</a>), a full stack web
framework</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>(Sorry if I neglected your Clojure tool!)</p>
</div>
<div class="paragraph">
<p>Thanks to the following people who read drafts of this article and helped me
develop it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mark Bastian</p>
</li>
<li>
<p>[Dmitri Sotnikov aka @yogthos](<a href="https://twitter.com/yogthos">https://twitter.com/yogthos</a>)</p>
</li>
<li>
<p>Joe Jackson</p>
</li>
<li>
<p>Sergey Shvets</p>
</li>
<li>
<p>Kenneth Kalmer</p>
</li>
<li>
<p>Sean whose last name I don&#8217;t know</p>
</li>
<li>
<p>Tom Brooke</p>
</li>
<li>
<p>Patrick whose last name I don&#8217;t know (update: It&#8217;s Patrick French!)</p>
</li>
<li>
<p>Fed Reggiardo</p>
</li>
<li>
<p>Vincent Raerek</p>
</li>
<li>
<p>Ernesto de Feria</p>
</li>
<li>
<p>Bobby Towers</p>
</li>
<li>
<p>Chris Oakman</p>
</li>
<li>
<p>The TriClojure meetup</p>
</li>
</ul>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
    <a href="https://github.com/sweet-tooth-clojure/">Sweet Tooth</a>, a single-page app framework for Clojure
</footer>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
