<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Initial Rendering :: Sweet Tooth, a Clojure Single-Page App Framework</title>
    <link rel="canonical" href="https://www.sweettooth.dev/todo-example/dev/initial-rendering.html">
    <link rel="prev" href="index.html">
    <link rel="next" href="form-handling.html">
    <meta name="generator" content="Antora 2.3.3">
    <link rel="stylesheet" href="../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.sweettooth.dev">Sweet Tooth, a Clojure Single-Page App Framework</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="https://github.com/sweet-tooth-clojure/">GitHub Repos</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/endpoint">endpoint</a>
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/frontend">frontend</a>
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/todo-example">todo example</a>
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/describe">describe</a>
            <a class="navbar-item" href="https://github.com/sweet-tooth-clojure/documentation">documentation</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="todo-example" data-version="dev">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
      <!-- <h3 class="title"><a href="index.html">To-Do Example Walkthrough</a></h3> -->
      <h3 class="title"><a href="../../overview/dev/index.html">Overview</a></h3>
        <h3 class="title"><a href="../../quickstart/dev/index.html">Quickstart</a></h3>
        <h3 class="title"><a href="index.html">To-Do Example Walkthrough</a></h3>
  <ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="initial-rendering.html">Initial Rendering</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="form-handling.html">Form Handling</a>
  </li>
</ul>
  </li>
</ul>
      <h3 class="title"><a href="../../endpoint/dev/index.html">endpoint</a></h3>
  <ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../endpoint/dev/routes-and-handlers/index.html">Routes and Handlers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../endpoint/dev/routes-and-handlers/routes-in-depth.html">Routes in Depth</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../endpoint/dev/routes-and-handlers/handlers-in-depth.html">Handlers in Depth</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../endpoint/dev/routes-and-handlers/responses.html">Responses</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../endpoint/dev/routes-and-handlers/request-handling-intro.html">Introduction to Request Handling</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../endpoint/dev/architecture/index.html">Server Architecture: Components and Beyond</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../endpoint/dev/architecture/integrant-tutorial.html">Integrant Tutorial</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../endpoint/dev/architecture/duct-tutorial.html">Duct Tutorial</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../endpoint/dev/systems/index.html">Systems</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">To-Do Example Walkthrough</span>
    <span class="version">dev</span>
  </div>
  <ul class="components">
    <li class="component">
      <span class="title">endpoint</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../endpoint/dev/index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Overview</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../overview/dev/index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Quickstart</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../quickstart/dev/index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <span class="title">To-Do Example Walkthrough</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">dev</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../overview/dev/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">To-Do Example Walkthrough</a></li>
    <li><a href="initial-rendering.html">Initial Rendering</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<article class="doc">
<h1 class="page">Initial Rendering</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>What&#8217;s involved in displaying the initial form and sidebar? If you
look in the <code>sweet-tooth.todo-example.frontend.core</code> namespace, you&#8217;ll
see:</p>
</div>
<div class="listingblock">
<div class="title">initial rendering fns</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(defn system-config
  "This is a function instead of a static value so that it will pick up
  reloaded changes"
  []
  (mm/meta-merge stconfig/default-config
                 {::stfr/frontend-router {:use    :reitit
                                          :routes froutes/frontend-routes}
                  ::stfr/sync-router     {:use    :reitit
                                          :routes (ig/ref ::eroutes/routes)}

                  ;; Treat handler registration as an external service,
                  ;; interact with it via re-frame effects
                  ::stjehf/handlers {}
                  ::eroutes/routes  ""}))

(defn -main []
  (rf/dispatch-sync [::stcf/init-system (system-config)])
  (rf/dispatch-sync [::stnf/dispatch-current])
  (r/render [app/app] (stcu/el-by-id "app")))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most of this will be unfamiliar, but you look at the very last line
you&#8217;ll see some code you might recognize:</p>
</div>
<div class="listingblock">
<div class="title">here&#8217;s where we render</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(r/render [app/app] (stcu/el-by-id "app"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re rendering the <code>app/app</code> component to the <code>&lt;div id="app"&gt;&lt;/div&gt;</code> DOM
element. Here&#8217;s what the <code>app/app</code> component looks like:</p>
</div>
<div class="listingblock">
<div class="title">the <code>app/app</code> component</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(defn app
  []
  [:div.app
   [:div.head
    [:div.container [:a {:href (stfr/path :home)} "Wow! A To-Do List!"]]]
   [:div.container.grid
    [:div.side @(rf/subscribe [::stnf/routed-component :side])]
    [:div.main @(rf/subscribe [::stnf/routed-component :main])]]])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hmm. There&#8217;s still nothing here that looks like the forms we see in
the sidebar and main area. What&#8217;s going on? Here&#8217;s the high level
overview, which I&#8217;ll explain in detail in the sections that follow:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Integrant initializes system components</p>
</li>
<li>
<p>One component is a <em>router</em> that associates URL patterns with</p>
<div class="ulist">
<ul>
<li>
<p>What components to display</p>
</li>
<li>
<p>Lifecycle callbacks that should get dispatched on entering or
exiting a route</p>
<div class="paragraph">
<p>(I haven&#8217;t shown the router code that ties routes to components and
lifecycle callbacks, but I&#8217;ll introduce you to it later.)</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Another component is a <em>nav handler</em> that reacts to nav events by
looking up the corresponding <em>route</em>, dispatching its lifecycle,
and setting it as the current route in the appdb</p>
</li>
<li>
<p>The <code>[::stnf/dispatch-current]</code> re-frame event causes the nav
handler to handle the current URL, dispatching its lifecycle and
setting the current route</p>
</li>
<li>
<p>The <code>::stnf/routed-component</code> subscription pulls components for the
current route out of the app db, and those components get rendered</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now let&#8217;s go through all this in detail.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_app_initialization"><a class="anchor" href="#_app_initialization"></a>App Initialization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When you open the home page, the app renders the home page&#8217;s
components. For most projects, your app must perform some kind of
initialization process (to set up route handling, for example) to get
to this point. How does a Sweet Tooth app do it?</p>
</div>
<div class="paragraph">
<p>Briefly, Sweet Tooth provides a re-frame handler to initialize an <a href="https://github.com/weavejester/integrant">Integrant</a>
<em>system</em> (check out the Integrant docs for a description of what a system is and
how Integrant provides a mechanism for starting and stopping components). The
system includes a component for managing nav events, like loading the initial
page or clicking a link. This nav component looks up the <em>route</em> for the current
URL in a <a href="https://github.com/metosin/reitit">reitit</a> router. The route defines <em>lifecycle callbacks</em> and also defines
which high-level components should get displayed.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll look at each of these parts of the framework and how we use them
in our app.</p>
</div>
<div class="paragraph">
<p>First, let&#8217;s look at the <code>sweet-tooth.todo-example.frontend.core</code>
namespace again:</p>
</div>
<div class="listingblock">
<div class="title">system config</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(defn system-config
  "This is a function instead of a static value so that it will pick up
  reloaded changes"
  []
  (mm/meta-merge stconfig/default-config
                 {::stfr/frontend-router {:use    :reitit
                                          :routes froutes/frontend-routes}
                  ::stfr/sync-router     {:use    :reitit
                                          :routes (ig/ref ::eroutes/routes)}

                  ;; Treat handler registration as an external service,
                  ;; interact with it via re-frame effects
                  ::stjehf/handlers {}
                  ::eroutes/routes  ""}))

(defn -main []
  (rf/dispatch-sync [::stcf/init-system (system-config)])
  (rf/dispatch-sync [::stnf/dispatch-current])
  (r/render [app/app] (stcu/el-by-id "app")))</code></pre>
</div>
</div>
<div class="paragraph">
<p>As is tradition for Lispers, let&#8217;s start at the bottom and work our
way up. In the <code>-main</code> function, you can see we&#8217;re dispatching two
events and then rendering a component. Let&#8217;s walk through the
mechanics of what&#8217;s going on, and then we&#8217;ll talk about why it works
the way it does.</p>
</div>
<div class="paragraph">
<p>The first event is:</p>
</div>
<div class="listingblock">
<div class="title">first event</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(rf/dispatch-sync [::stcf/init-system (system-config)])</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>(system-config)</code> returns an Integrant config, a map describing a
system where each key corresponds to the name of a <em>system component</em>
(as opposed to a React compononent) and each value is that component&#8217;s
configuration. Examples of system components include nav handlers that
react to History events and web worker managers.</p>
</div>
<div class="paragraph">
<p>Sweet Tooth comes with a bunch o' system components that are meant to make your
life easier, and the default config for those components lives at
<code>stconfig/default-config</code>. In the <code>system-config</code> function we merge the default
Sweet Tooth config with our app&#8217;s particular config. We use <a href="https://github.com/weavejester/meta-merge"><code>meta-merge</code></a> because
of its support for deep merging and because of how it gives you some control
over how the two values get merged.</p>
</div>
<div class="paragraph">
<p>This system config is the payload for the <code>::stcf/init-system</code> event. This event
<a href="https://github.com/sweet-tooth-clojure/frontend/blob/master/src/sweet_tooth/frontend/core/flow.cljc#L123">results in integrant getting called</a> to <em>initialize</em> the system:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(rf/reg-event-fx ::init-system
  (fn [_ [_ config]]
    {::init-system config}))

(rf/reg-fx ::init-system
  (fn [config]
    (reset! rfdb/app-db {:sweet-tooth/system (-&gt; config
                                                 ig/prep
                                                 ig/init)})))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Integrant initializes an app by initializing individual components in
dependency order; the nav handler component depends on a router
component, so the router gets initialized before the nav handler.</p>
</div>
<div class="paragraph">
<p>Why do we use Integrant to initialize our app? A few reasons:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Sometimes we want to render different React components at different
stages of the system&#8217;s readiness. For example, you might want to
show a loading indicator while the app sets up whatever state is
necessary for it to be used, and then render the app proper once
the system is ready. Integrant makes it a lot easier to determine
when the system is ready.</p>
</li>
<li>
<p>Integrant has a very simple model for handling both initializing
<em>and</em> halting a system. This is very useful for local development
with livereload when you have components that modify global state,
for example by attaching event listeners to the window. Livereload
can call <code>(ig/halt!)</code> on the system, giving each component to clean
up after itself (remove its listeners) before code gets reloaded.</p>
</li>
<li>
<p>Integrant makes it easier to code to interfaces. The nav handler
component depends on a router, and by default it depends on a
reitit router. However, you could provide a bidi or silk router
instead, as long as it can conform to the same interface. (This
isn&#8217;t particular to the initialization process per se but I threw
it in because why not!?)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So that explains Integrant and how it fits into the app initialization
process, the first step in the <code>-main</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(defn -main []
  (rf/dispatch-sync [::stcf/init-system (system-config)])
  (rf/dispatch-sync [::stnf/dispatch-current])
  (r/render [app/app] (stcu/el-by-id "app")))</code></pre>
</div>
</div>
<div class="paragraph">
<p>To understand the next step, <code>(rf/dispatch-sync
[::stnf/dispatch-current])</code>, we&#8217;ll take a closer look at Sweet Tooth&#8217;s
<em>nav handler</em> component.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_nav_handler_component"><a class="anchor" href="#_the_nav_handler_component"></a>The nav handler component</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can see the nav handler&#8217;s default config in the
<a href="https://github.com/sweet-tooth-clojure/frontend/blob/master/src/sweet_tooth/frontend/config.cljs"><code>sweet-tooth.frontend.config</code></a> namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">{::stnf/handler {:dispatch-route-handler ::stnf/dispatch-route
                 :check-can-unload?      true
                 :router                 (ig/ref ::stfr/frontend-router)
                 :global-lifecycle       (ig/ref ::stnf/global-lifecycle)}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>On initialization, it <a href="https://github.com/sweet-tooth-clojure/frontend/blob/master/src/sweet_tooth/frontend/nav/flow.cljs#L26">uses an adapted version of the accountant library</a> to
register javascript event handlers for nav events. These <em>javascript event</em>
handlers will dispatch <em>re-frame events</em>; Sweet Tooth&#8217;s default configuration,
above, has the js event handlers dispatching the <code>::stnf/disptach-route</code>
re-frame event by default. In extremely simplified pseudocode, it&#8217;s as if the
following gets evaluated when the nav component is initialized:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(js/listen js/NavEvent #(rf/dispatch [::stnf/dispatch-route]))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>::stnf/dispatch-route</code> is one of the gnarlier bits of Sweet Tooth,
and we don&#8217;t need to go into all the details of how it works.
Ultimately what it does is:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Figures out what <em>route</em> corresponds to the potential new URL
proposed by the navigation event using a <em>router</em>. (I say
<em>potential</em> URL because it&#8217;s possible for nav events to get
rejected.)</p>
</li>
<li>
<p>Dispatches the route&#8217;s <em>lifecycle callbacks</em></p>
</li>
<li>
<p>Sets the currently active route in the re-frame app db</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In the -main function, we see <code>(rf/dispatch-sync
[::stnf/dispatch-current])</code>. This behaves almost identically to
<code>::stnf/dispatch-route</code>; the only difference is that it operates on
the current URL.</p>
</div>
<div class="paragraph">
<p>To understand this process fully, we&#8217;ll need to look at this router that I keep
talking about.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_router_component"><a class="anchor" href="#_the_router_component"></a>The router component</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I kept saying that the nav handler uses a router to look up
routes. Where does the router come from? You can see it in the config
for the nav handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">{::stnf/handler {:dispatch-route-handler ::stnf/dispatch-route
                 :check-can-unload?      true
                 :router                 (ig/ref ::stfr/frontend-router) ;; &lt;--- There it is!
                 :global-lifecycle       (ig/ref ::stnf/global-lifecycle)}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The config includes a <em>reference</em> to another component,
<code>::stfr/frontend-router</code>. We actually saw the configuration for <em>that</em> component
in <code>sweet-tooth.todo-example.frontend.core</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(defn system-config
  "This is a function instead of a static value so that it will pick up
  reloaded changes"
  []
  (mm/meta-merge stconfig/default-config
                 {::stfr/frontend-router {:use    :reitit
                                          :routes froutes/frontend-routes}
                  ::stfr/sync-router     {:use    :reitit
                                          :routes (ig/ref ::eroutes/routes)}

                  ;; Treat handler registration as an external service,
                  ;; interact with it via re-frame effects
                  ::stjehf/handlers {}
                  ::eroutes/routes  ""}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>So the <code>::stfr/frontend-router</code> component gets initialized with this
configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">{:use    :reitit
 :routes froutes/frontend-routes}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:use</code> specifies what library should be used to parse route data into
a router, and reitit is supported out of the box. <code>:routes</code> specifies
the route data. Here&#8217;s <code>froutes/frontend-routes</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(ns sweet-tooth.todo-example.frontend.routes
  (:require [sweet-tooth.frontend.sync.flow :as stsf]
            [sweet-tooth.frontend.form.flow :as stff]
            [sweet-tooth.frontend.nav.flow :as stnf]
            [sweet-tooth.todo-example.cross.validate :as v]
            [sweet-tooth.todo-example.frontend.components.home :as h]
            [sweet-tooth.todo-example.frontend.components.todo-lists.list :as tll]
            [sweet-tooth.todo-example.frontend.components.todo-lists.show :as tls]
            [sweet-tooth.todo-example.frontend.components.ui :as ui]
            [clojure.spec.alpha :as s]
            [reitit.coercion.spec :as rs]))

(s/def :db/id int?)

(def frontend-routes
  [["/"
    {:name       :home
     :lifecycle  {:param-change [::stsf/sync-once [:get :todo-lists]]}
     :components {:side [tll/component]
                  :main [h/component]}
     :title      "To-Do List"}]

   ["/todo-list/{db/id}"
    {:name       :show-todo-list
     :lifecycle  {:param-change [[::stff/initialize-form [:todos :create] {:validate (ui/validate-with v/todo-rules)}]
                                 [::stsf/sync-once [:get :todo-lists]]
                                 [::stnf/get-with-route-params :todo-list]]}
     :components {:side [tll/component]
                  :main [tls/component]}
     :coercion   rs/coercion
     :parameters {:path (s/keys :req [:db/id])}
     :title      "To-Do List"}]])</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that each route has a <code>:components</code> key, a map with
<code>:side</code> and <code>:main</code> keys. When you load the home page, <code>tll/component</code>
shows up in the side bar, and <code>tls/component</code> shows up in the "main"
column.</p>
</div>
<div class="paragraph">
<p>At the beginning of all this I asked how the <code>app</code> component worked:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-clojure hljs" data-lang="clojure">(defn app
  []
  [:div.app
   [:div.head
    [:div.container [:a {:href (stfr/path :home)} "Wow! A To-Do List!"]]]
   [:div.container.grid
    [:div.side @(rf/subscribe [::stnf/routed-component :side])]
    [:div.main @(rf/subscribe [::stnf/routed-component :main])]]])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we have all the pieces to solve the puzzle:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A nav handler gets created on initialization</p>
</li>
<li>
<p>It&#8217;s passed a router that associates URL paths with components</p>
</li>
<li>
<p>We dispatch <code>(rf/dispatch-sync [::stnf/dispatch-current])</code>. This
sets the current route in the re-frame app db.</p>
</li>
<li>
<p>The <code>::stnf/routed-component</code> subscription looks up the
<code>:component</code> key for the current route in the app db.</p>
</li>
<li>
<p>Those components get rendered.</p>
</li>
</ol>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="index.html">To-Do Example Walkthrough</a></span>
  <span class="next"><a href="form-handling.html">Form Handling</a></span>
</nav>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
    <a href="https://github.com/sweet-tooth-clojure/">Sweet Tooth</a>, a single-page app framework for Clojure
</footer>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
